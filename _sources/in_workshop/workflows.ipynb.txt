{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Workflows for Earth Science"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Workflows for Earth and Natural sciences**\n",
        "- Collaborating with Git/GitHub (workflows and best practices)\n",
        "- Open Source Software best practices\n",
        "- Using your Python workflow on a remote server\n",
        "- Popular AI Agents for software and their use cases "
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Collaborating with Git"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Open Source Software Best Practices"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Thinking About Data Storage for Open Science"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "vscode": {
          "languageId": "plaintext"
        }
      },
      "source": [
        "Cloud-optimized formats for Geospatial data include: Cloud-Optimized GeoTIFF (COG), GeoParquet, Zarr, FlatGeobuf, Cloud-Optimized Point Clouds (COPC), and more\n",
        "\n",
        "There are many possible ways to do data storage. If you are able to store your data so that data acquisition integrates with tools like Xarray and Dask, then\n",
        "your platform will be all the more powerful and accessible. There is no one way to do this, and it is important to consider where your users will be doing their analysis, \n",
        "how much data they will need at a time, and how they will query the main database to find what they want. \n",
        "\n",
        "If possible, using a cloud-optimized format is ideal. It will make access to and use of the data more efficient, in some cases by orders of magnitude."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "[Zarr](https://zarr.dev/) \n",
        "\n",
        "[What is Zarr?](https://earthmover.io/blog/what-is-zarr)\n",
        "\n",
        "[Zarr and Xarray](https://tutorial.xarray.dev/intermediate/intro-to-zarr.html) \n",
        "\n",
        "[Example project: CryoCloud](https://book.cryointhecloud.com/) \n",
        "\n",
        "[International Interactive Computing Collaboration](https://2i2c.org/)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Migrating Your Workflow to a Remote Server"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We will discuss to popular ways to use Python and Conda on a server:\n",
        "\n",
        "1) VSCode Remote-SSH\n",
        "\n",
        "2) Jupyter Notebooks with SSH Tunneling\n",
        "\n",
        "3) Python scripts run in a detached terminal with `screen` or `tmux`"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### VSCode and Remote-SSH \n",
        "\n",
        "The VSCode Extension **Remote-SSH** allows you to SSH into a server through the code-editor. You will then be able to navigate your files on the server, load conda environments, and save files with the exact same interface you use on your laptop.\n",
        "\n",
        "1) Install the Remote-SSH extension in VSCode\n",
        "\n",
        "2) Open the control panel (cmd + shift + p)\n",
        "\n",
        "3) Type `Remote-SSH` and select `Remote-SSH: Connect to Host...`\n",
        "\n",
        "4) Select `+ Add New SSH Host`\n",
        "\n",
        "5) Enter the credentials for your server\n",
        "\n",
        "6) Enter your password\n",
        "\n",
        "This will log you into your server and will open a new VSCode window (which will be in the filesystem on the server). The first time you do this, you may have to wait a few minutes after logging in while VSCode installs the necessary tools on the server side. After you have done this the first time, you will be able to select the host name from the list of known hosts (instead of adding a new one) and input your password. You will no longer need to type out ssh username@ip_address."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Jupyter Notebooks with SSH Tunneling\n",
        "\n",
        "1) Log into your server (ssh username@your-server-address)\n",
        "\n",
        "2) Run `jupyter-lab --no-browser` in the folder you want to work from\n",
        "\n",
        "3) jupyter lab will start, and the output in the terminal will include a line that looks like `Or copy and paste one of these URLs: http://localhost:8888/lab?token=some-long-token`\n",
        "\n",
        "    a) The port number (in this case 8888) is the port on the server that the jupyter lab information is piped to\n",
        "\n",
        "    b) We need to link a port on the laptop to the port on the server and then we can open the webpage like we are used to\n",
        "\n",
        "4) open a new terminal and run `ssh -L 8888:localhost:8888 username@your-server-address`\n",
        "\n",
        "    a) This links port localhost port 8888 on our laptop to localhost port 8888 on the server. These numbers don't have to be the same.\n",
        "\n",
        "    b) If port 8888 on our laptop is taken, we can try another number. `ssh -L 8890:localhost:8888 username@your-server-address`. The server port needs to match the number in the jupyter lab output.\n",
        "\n",
        "    c) Enter your password\n",
        "\n",
        "5) Copy and paste the URL from the jupyter lab output into your web browser (`http://localhost:8888/lab?token=some-long-token`)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Running Python Scripts in a Detached Terminal\n",
        "\n",
        "The `tmux` command allows you to open terminals in which you can start a program that won't die even when the terminal is closed. This is useful for running on a server because a normal terminal will kill whatever process is running if you close the window, close your computer, or lose your internet connection. That is not a practical way to work if we need to run programs that take a long time.\n",
        "\n",
        "`screen` is an alternative to `tmux`, although it is somewhat outdated.\n",
        "\n",
        "This workflow would look something like:\n",
        "\n",
        "1) Develop your Python script on a small set of data. This could be done in a Jupyter notebook or python script on the server or on your laptop. \n",
        "\n",
        "2) Organize the analysis you need to do into a script or set of scripts.\n",
        "\n",
        "3) Open a terminal with the appropriate `tmux` or `screen` command (see instructions below).\n",
        "\n",
        "4) Activate your conda environment.\n",
        "\n",
        "5) Run your Python program. Alternatively you could have a bash script that runs a whole list of Python programs.\n",
        "\n",
        "At this point you can close the terminal and your programs will continue to run on the server."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Using Git to Move and Track your Work\n",
        "\n",
        "Git repositories provide an easy way to move work between locations (and to make sure you don't lose anything because you are switching between platforms). To use Git on a server:\n",
        "\n",
        "1) Log into the server\n",
        "\n",
        "2) Generate a new SSH key pair (the key pair should end up in your home directory on the server at ~/.ssh/)\n",
        "\n",
        "3) Add the _public_ key to your GitHub profile through Settings -> SSH and GPG Keys -> Add SSH key\n",
        "\n",
        "Once you have done the above, you can use your Git account to track the work you do on the server. Your research project repo can be downloaded on both the server and on your local computer. When you make changes in one place, you can add, commit, and push them. When you return to the other location you can do a `git pull` to see the updated work. \n",
        "\n",
        "An example workflow:\n",
        "\n",
        "1) Starting a project from scratch: Create a repo on your local computer or in your GitHub account. Clone that repo to the server. Do your work in the repo. Before you log out, add and commit the changes. Return to your local computer and `git pull` to see the updated project without being logged into the computer. This is a great way to keep figures up to date. You will generate new figures, commit and push both the figures and the code that generated them, and then pull them to your local computer. This negates the need to use `scp` or `rsync` to continually move around copies of your figures and prevents confusion about which code generated which version of the figures.\n",
        "\n",
        "2) Tracking an existing project: Log onto your server. Navigate into a directory where you have code for your project. Use `git init` to make the project into a repository (make sure to have a .gitignore file!). Push the repo to your GitHub. Proceed with your work on the server. Add and commit (and push) any changes before you log out. Return to your local computer, use the link on GitHub to clone your repository. Now you can see the work you were doing on the server!"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Bash Scripting"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We should insert a couple quick examples (what to put in a bash script). But we don't need to get fancy. How to execuate any one specific task is a good ChatGPT question."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## AI Agents and Tools for Coding"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The world of AI tools for coding is evolving rapidly... and everything we talk about in this lesson will likely be out of date soon. This discussion is intended to provide a bit of guidance that will likely remain relevant, even as the agents themselves evolve. We will not discuss an exhaustive list of agents, and instead we will touch on a few that are popular right now (August 2025). Our goal is to shed a bit of light on how AI could augment your workflow, how they are being used to generate new code that you may interact with, and how they can also waste your time or lead you down rabbit holes.\n",
        "\n",
        "The AI tools we will discuss today are:\n",
        "- ChatGPT (AI chat bot)\n",
        "- GitHub Co-Pilot (AI assistant in your IDE)\n",
        "- Cursor (AI-native IDE)\n",
        "- Claude Code (AI command line tool)\n",
        "\n",
        "The differences between these tools include the size and scope of their _context_ window in addition to their level of autonomy, interactivity, and control. The more *agentic* a tool is, the more it is able to reason, debug, execute code, and generate new content on its own.\n",
        "\n",
        "The above tools are primariliy based on these Large-language models (LLMs), all of which are proprietary:\n",
        "- Anthropic's Claude models (Claude Opus, Claude Sonnet, and Claude Haiku)\n",
        "- OpenAI's GPT models (GPT-3.5, GPT-4, GPT4-Turbo)\n",
        "\n",
        "All of these tools also have tiered access with subscription plans, and in general their usage is capped, even for subscribers."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### What is the context window?"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### What are these models trained on?\n",
        "\n",
        "- GitHub public repositories\n",
        "- Stack Overflow\n",
        "- Technical documentation\n",
        "- Programming textbooks and tutorials\n",
        "- Natural language + code mix (e.g., docstrings, commit messages)\n",
        "- Some (like Claude and GPT-4) are multi-modal and can reason about code in text, files, and diagrams."
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### What are the implications of AI in software? Are these tools making our research better? \n",
        "\n",
        "The links below are intended to provoke discussion, and provide a bit of caution. They do not reflect the opinions of anyone in the software workshop. It is worth thinking about when and where to use AI in your workflow, such that you make your work better not worse.\n",
        "\n",
        "[Does AI Understand Bugs?](https://venturebeat.com/ai/ai-can-fix-bugs-but-cant-find-them-openais-study-highlights-limits-of-llms-in-software-engineering/)   \n",
        "\n",
        "[Are developers getting less efficient?](https://arxiv.org/abs/2507.09089)\n",
        "\n",
        "[Are AI bugs worse than normal bugs?](https://doctorow.medium.com/https-pluralistic-net-2025-08-04-bad-vibe-coding-maximally-codelike-bugs-8372979b3933)\n",
        "\n",
        "These models are just statistical tools. They cannot genuinely reason, and they hallucinate all of the time (i.e., they generate false information without indicating that their response is not reliable). In some cases the tool will even double down on its hallucination unless prompted in the right way. \n",
        "\n",
        "For example, a few weeks ago I asked ChatGPT to generate an Apple Keynote file for me, not thinking about the fact that Keynote is a proprietary format (therefore it cannot do this). It generated several garbage files before I asked whether it was actually capable of completing the task. It responded by telling me that it definitely could and would do it by \"handling it outside of ChatGPT\". The rest of our conversation is below:"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "<img src=\"_static/chat_gpt_hallucination.png\" width=\"750\">"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python",
      "version": "3.12.6"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}
